---
title: Funciones y objetos
description: 'Funciones. Des-estructuraci√≥n. Objetos. Prototipos. Paradigma Funcional: funciones como objetos. Paradigma de orientaci√≥n a objetos: clases'
date: 2025-01-13
tags: [JS, ES, development language]
serie: { 'id': 6, 'title': 'JavaScript' }
serieOrder: 4
---

- [Funciones](#funciones)
  - [Creaci√≥n y uso](#creaci√≥n-y-uso)
    - [Declaraci√≥n v. asignaci√≥n](#declaraci√≥n-v-asignaci√≥n)
    - [Ejecuci√≥n, invocaci√≥n o llamada](#ejecuci√≥n-invocaci√≥n-o-llamada)
    - [Re-asignaci√≥n](#re-asignaci√≥n)
    - [Hoisting](#hoisting)
  - [√Åmbito (scope) de las variables](#√°mbito-scope-de-las-variables)
  - [Par√°metros v. argumentos](#par√°metros-v-argumentos)
    - [Argumentos de tipo primitivo](#argumentos-de-tipo-primitivo)
    - [Argumentos de tipo referenciado](#argumentos-de-tipo-referenciado)
- [Des-estructuraci√≥n (Destructuring)](#des-estructuraci√≥n-destructuring)
  - [Des-estructuraci√≥n en la declaraci√≥n de variables](#des-estructuraci√≥n-en-la-declaraci√≥n-de-variables)
  - [Des-estructuraci√≥n en la asignaci√≥n de valores a las variables](#des-estructuraci√≥n-en-la-asignaci√≥n-de-valores-a-las-variables)
  - [Des-estructuraci√≥n en la declaraci√≥n de par√°metros](#des-estructuraci√≥n-en-la-declaraci√≥n-de-par√°metros)
  - [Operador spread (extendido)](#operador-spread-extendido)
    - [Shallow clone (or copy)](#shallow-clone-or-copy)
    - [Deep clone (or copy)](#deep-clone-or-copy)
  - [Operador rest](#operador-rest)
- [Objetos](#objetos)
  - [Creaci√≥n y tipos de objetos](#creaci√≥n-y-tipos-de-objetos)
    - [Objetos literales](#objetos-literales)
    - [Objetos construidos](#objetos-construidos)
  - [Propiedades de los objetos](#propiedades-de-los-objetos)
    - [Niveles](#niveles)
      - [Anidamiento y propiedades undefined](#anidamiento-y-propiedades-undefined)
      - [Anidamiento y clonaci√≥n](#anidamiento-y-clonaci√≥n)
    - [Iteraciones](#iteraciones)
  - [Objetos y prototipos](#objetos-y-prototipos)
    - [Propiedades del prototipo original](#propiedades-del-prototipo-original)
    - [Prototipos y funciones](#prototipos-y-funciones)
    - [Cambiando el prototipos](#cambiando-el-prototipos)
    - [Cadena de prototipos](#cadena-de-prototipos)
- [Paradigma funcional: funciones como objetos](#paradigma-funcional-funciones-como-objetos)
  - [Funciones con propiedades 'extra'](#funciones-con-propiedades-extra)
  - [Funciones anidadas](#funciones-anidadas)
  - [Funciones de orden superior y callbacks](#funciones-de-orden-superior-y-callbacks)
  - [Funciones auto-invocadas](#funciones-auto-invocadas)
  - [Closures](#closures)
- [Paradigma de orientaci√≥n a objetos: clases](#paradigma-de-orientaci√≥n-a-objetos-clases)
  - [Patrones de ejecuci√≥n de las funciones](#patrones-de-ejecuci√≥n-de-las-funciones)
  - [Funciones constructoras](#funciones-constructoras)
    - [Funciones constructoras y prototipos](#funciones-constructoras-y-prototipos)
    - [M√©todos de instancia y m√©todos de prototipo](#m√©todos-de-instancia-y-m√©todos-de-prototipo)
    - [Propiedades y M√©todos est√°ticos (de "clase")](#propiedades-y-m√©todos-est√°ticos-de-clase)
    - [Herencia](#herencia)
    - [Funciones constructoras nativas de JS](#funciones-constructoras-nativas-de-js)
  - [Clases en ES6](#clases-en-es6)
  - [Accessors: getters y setters](#accessors-getters-y-setters)
  - [JS y la programaci√≥n orientada a objetos](#js-y-la-programaci√≥n-orientada-a-objetos)
    - [Relaciones entre clases](#relaciones-entre-clases)

## Funciones

Son

- conjuntos de instrucciones,
- generalmente asociados a un **identificador**,
- gracias a lo cual pueden ser **invocadas** (ejecutadas)
- con su propio espacio de memoria (**scope**)

En todos los casos, cuando concluyen la ejecuci√≥n, **retornan** (devuelven) un valor.
Si este es undefined la funci√≥n se considera de tipo **void**.

### Creaci√≥n y uso

En JS las funciones son tambi√©n valores y su tipo es el de **objetos 'de pleno derecho**.
Esto determina que ademas de declararlas, sea posible asignarlas a una variable, como sucede con cualquier valor (incluidos los de tipo objeto)

#### Declaraci√≥n v. asignaci√≥n

Se pueden crear funcione mediante **declaraci√≥n**

En ella se incluye la implementaci√≥n (cuerpo de la funci√≥n): el conjunto de funciones que ser√° ejecutado.

```js
function foo() {
  // Implementaci√≥n
  console.log('Soy foo');
}
```

la alternativa es la **asignaci√≥n** de una **expresi√≥n functional** (function expression) o **funci√≥n an√≥nima** a una variable

```js
const bar = function () {
  // Implementaci√≥n
};
```

En ES6, la expresi√≥n funcional puede escribirse como **arrow function** [_üóìÔ∏èES2015_]

```js
const arrow = () => {
  // Implementaci√≥n
};
```

Cuando las arrow functions son de una sola l√≠nea que directamente retorna una expresi√≥n, pueden omitirse las llaves ({}) y el return

```js
const add = (a, b) => a + b;
```

Las arrow functions usan un **lexical scope**, a diferencia del **dynamic scope** de las funciones habituales.

Eso obliga a tener en cuenta algunas limitaciones en su uso

- no suelen usarse como **m√©todos**, ya que si lo son, no tendr√°n acceso al objeto mediante `this` ni al padre como `super`
- no pueden usarse como funciones **constructoras**
- no pueden usarse como **generadores** porque en su implementaci√≥n no pueden usar el operador `yield`

#### Ejecuci√≥n, invocaci√≥n o llamada

Cualquiera que sea la forma en que se a creado, la funci√≥n se invoca o ejecuta usando su identificador + el **operador de invocaci√≥n**, los par√©ntesis

```js
identificador();
```

En ese momento, js crea un nuevo entorno de ejecuci√≥n (**execution scope**) en el que existen las variables locales de la funci√≥n (incluidos los par√°metros)

Cuando la ejecuci√≥n concluye, la funci√≥n devuelve el valor que corresponda (puede ser undefined), y el entorno de ejecuci√≥n desaparece, con todas las variables locales que incluya

#### Re-asignaci√≥n

Usando el identificador de una funci√≥n, sin el operador de invocaci√≥n (los par√©ntesis), puede asignarse su valor a otra variable.

Tendremos as√≠ dos identificadores diferentes que hacen referencia a una misma funci√≥n (bloque de c√≥digo)

```js
const countWeekDays = function () {
  return 7;
};

const weekDays = countWeekDays;
console.log(weekDays);

console.log(countWeekDays());
console.log(weekDays());
```

#### Hoisting

La llamada (o invocaci√≥n) a la funci√≥n declarada como funci√≥n puede ser anterior a su declaraci√≥n.
Esto se debe al proceso conocido como alzamiento (**hoisting**) o visibilidad sint√°ctica: las declaraciones de variables con var y las funciones declaradas con function son alzadas al principio por el interprete de JS

```js
foo(); // Ejemplo de Hoisting
// ReferenceError bar();
// ReferenceError arrow();

function foo() {
  // Implementaci√≥n
}

const bar = function () {
  // Implementaci√≥n
};

const arrow = () => {
  // Implementaci√≥n
};
```

Cuando una funci√≥n se crea mediante asignaci√≥n a una variable, el proceso de alzamiento no se produce

### √Åmbito (scope) de las variables

Las variables declaradas directamente fuera de cualquier funci√≥n tienen un √°mbito global o del m√≥dulo en que existen.

Las variables declaradas como par√°metros o dentro de una funci√≥n tienen un √°mbito local a la funci√≥n.

- no pueden ser accedidas desde fuera de la funci√≥n
- desaparecen cuando concluye la ejecuci√≥n de la funci√≥n

Cuando el identificador de una variable local es el mismo que el de una de √°mbito (scope) superior, ensombrece (shadow) a esta √∫ltima, de modo que no puede ser accedida.

```js
let text1 = 'Valor inicial';
let text2 = 'Valor inicial';

function foo() {
  var text1;
  text1 = 'Cambio desde dentro';
  text2 = 'Cambio desde dentro';
}

foo();
console.log(text1); // "Valor inicial"
console.log(text2); // "Cambio desde dentro
```

Al contrario de lo que sucede en el ejemplo, una funci√≥n **no debe** acceder a las variables globales, para evitar que quede **acoplada** al c√≥digo principal

### Par√°metros v. argumentos

Al invocar una funci√≥n se incluyen los **argumentos** (tambi√©n denominados par√°metros reales) necesarios: valores obtenidos al evaluar la expresi√≥n que se env√≠an a la funci√≥n

La funci√≥n recibe esos valores en variable locales denominadas **par√°metros** (o par√°metros formales) que se utilizan como parte de las operaciones llevadas a cabo en el cuerpo (implementaci√≥n) de la funci√≥n.

```js
const add = (x, y) => {
  const r = x + y;
  return r;
};
```

La funci√≥n tiene 3 variable locales:
r y los par√°metros x e y, que se inicializar√°n con los valores recibidos como argumentos.

```js
const x = 5;
console.log('Add', add(x)); // NaN
console.log('Add', add(x, 4)); // 9
console.log('Add', add(x, 4, 8)); // 9
```

La funci√≥n se invoca con diferente n√∫mero de argumentos

- si hay menos argumentos que par√°metros, los que no reciben argumento se inicializan con valor undefined
- si hay m√°s argumentos que par√°metros, los que sobran se ignoran

En ES6 es f√°cil definir los **valores por defecto**, de los par√°metros, de forma que se inicialicen con esos valores en caso de no recibir ning√∫n valor como argumento

```js
const add = (x = 0, y = 0) => {
  const r = x + y;
  return r;
};

const x = 5;
console.log('Add', add()); // 0
console.log('Add', add(x)); // 5
```

En VSC los valores por defecto se utilizan para inferir el tipo de los par√°metros, aunque ello no signifique que se fija ese tipo, como ocurrir√≠a en TypeScript

#### Argumentos de tipo primitivo

Si los argumentos son valores primitivos, lo que reciben los par√°metros es el **valor**.

La funci√≥n nunca cambia el valor de la variable que se usa como argumento, a no ser que la manipule directamente y esto √∫ltimo no deber√≠a ocurrir nunca.

```js
const foo = (x) => {
  x = x + 1;
  console.log('Valor de x local a foo', x); // 3
  return x;
};

const x = 2;
console.log('Valor inicial de x global', x); // 2
foo(x);
console.log('Valor finas de x global', x); // 2
```

#### Argumentos de tipo referenciado

Si los argumentos son objetos (valores primitivos), lo que reciben los par√°metros es la **referencia** a la instancia del objeto.

Si la funci√≥n **muta el objeto**, el cambio afecta a la instancia original, que es la √∫nica que existe

```js
const foo = (x) => {
  x.user = 'Juan';
  console.log('Valor de x local a foo', x); //  { user: 'Juan' }
  return x;
};

const x = { user: 'Pepe' };
console.log('Valor inicial de x global', x); //  { user: 'Pepe' }
foo(x);
console.log('Valor finas de x global', x); //  { user: 'Juan' }
```

## Des-estructuraci√≥n (Destructuring)

[_üóìÔ∏èES2015_]

En el proceso de declaraci√≥n de las variables y par√°metros, si el valor asignado es un objeto (o array), pueden recogerse por separado sus propiedades o items en variables completamente independientes

### Des-estructuraci√≥n en la declaraci√≥n de variables

```js
const createArray = () => [1, 2];
const createObject = () => ({
  name: 'Pepe',
  age: 22,
});

const [first, second] = createArray();
const { name, age } = createObject();

console.log(first, second); // 1 2
console.log(name, age); // Pepe 22
```

### Des-estructuraci√≥n en la asignaci√≥n de valores a las variables

```js
let [first, second] = createArray();
let { name, age } = createObject();

[first, second] = [10, 20];
({ name, age } = { name: 'Jose', age: 30 });

console.log(first, second); // 10 20
console.log(name, age); // Jose 30
```

### Des-estructuraci√≥n en la declaraci√≥n de par√°metros

```js
const useArray = ([first, second]) => {
  console.log(first);
  console.log(second);
};

useArray([1, 2]);

const useObject = ({ name, age }) => {
  console.log(name);
  console.log(age);
};

useObject({
  name: 'Pepe',
  age: 22,
});
```

### Operador spread (extendido)

Permite la expansi√≥n de iterables (arrays y strings) y objetos

- un iterable (arrays y strings) puede ser expandido
  - en llamadas de funci√≥n con cero o m√°s argumentos esperados
  - en objetos o arrays literales, donde se esperan nuevos elementos

Su uso en la llamada a una funci√≥n permite pasar un n√∫mero indefinido de argumentos, extra√≠dos a partir de un array

```js
const addTwoNumbers = (a, b) => a + b;
const numbers = [1, 2];
const result = addTwoNumbers(...numbers);

console.log(result); // 3
```

#### Shallow clone (or copy)

En la creaci√≥n de arrays literales, el operador spread permite la expansi√≥n de un objeto o array en lugares donde se esperan cero o m√°s elementos

```js
const numbers = [1, 2];
const numbersB = [...numbers];
console.log(numbersB); // [1,2]
```

Posteriormente JS a√±adi√≥ la posibilidad de expandir un objeto en lugares donde son esperados cero o m√°s pares de valores clave (para literales tipo Objeto) [_üóìÔ∏èES2018_]

```js
const obj = { name: 'Pepe', age: 22 };
const objB = { ...obj, age: 23 };

console.log(objB); // { name: 'Pepe', age: 23 }
```

El spread operator se convierte as√≠ en un mecanismo para la **copia o clonaci√≥n** de objetos (incluidos arrays): obtener una nueva instancia con las mismas propiedades o incluso con la mutaci√≥n de algunas

Este mecanismo no afecta a niveles anidados, es decir a arrays de arrays o propiedades de tipo objeto, por lo que se denomina **shallow copy**

![Shallow copy](assets/shallow.copy.svg)

#### Deep clone (or copy)

Para conseguir un deep clone pueden usarse 2 t√©cnicas

- uso de los m√©todos est√°ticos de JSON (stringify y parse)
- uso del la nueva funci√≥n global `structuredClone` incluida en las APIs del browser y node (desde su versi√≥n 11)

```js
const user = {
  name: {
    firstName: 'Pepe',
    surname: 'Perez',
  },
  age: 22,
};

const userB = JSON.parse(JSON.stringify(user));
console.log(userB);

const userC = structuredClone(userB);
console.log(userC);
```

### Operador rest

El operador rest al usarse en la sintaxis de los par√°metros de una funci√≥n le permite recibir un n√∫mero indefinido de argumentos como un array, permitiendo as√≠ representar funciones 'variadicas' (variadic functions) en JavaScript

```js
const sumNumbers = (...numbers) => {
  let accumulator = 0;
  for (const iterator of numbers) {
    accumulator += iterator;
  }
  return accumulator;
};

console.log(sumNumbers(2, 5, 3, 5, 2, 7, 7)); // 31
```

Tambi√©n puede emplearse el operador rest como parte del proceso de des-estructuraci√≥n

```js
const numbers = [1, 2, 3, 4, 5];
const [first, second, ...others] = numbers;
console.log(others); // [ 3, 4, 5 ]
```

Est√© √∫ltimo caso puede igualmente ocurrir con objetos [_üóìÔ∏èES2018_]

```js
const { first, second, ...others } = {
  first: 1,
  second: 2,
  third: 3,
  fourth: 4,
  fifth: 5,
};

console.log(first); // 1
console.log(second); // 2
console.log(others); // { third: 3, fourth: 4, fifth: 5 }
```

## Objetos

Como ya sabemos acerca de los objetos

- son valores de tipo referenciado
- son colecciones de **propiedades**, que a su vez son pares clave-valor
- los valores de las propiedades corresponden a datos de cualquier tipo: primitivos, objetos o funciones
  - En el caso de los arrays, los identificadores de las propiedades son indices num√©ricos que permiten la iteraci√≥n a lo largo del array
- cuando una propiedad es de tipo funci√≥n se denomina m√©todo.

### Creaci√≥n y tipos de objetos

Los objetos pueden declararse:

- literalmente
- con el patron constructor

#### Objetos literales

JS permite crear de forma literal objetos, arrays y expresiones regulares (RegExp),
todos ellos variaciones del tipo **object**

```js
const user = {
  name: 'Pepe',
  age: 22,
};

// Array
const numbers = [1, 2, 3, 4];

// Regular Expression (RegExp)
const regExp = /a/i;

console.log(user); // { name: 'Pepe', age: 22 }
console.log(numbers); // [ 1, 2, 3, 4 ]
console.log(regExp); // /a/i
```

Esta forma de notaci√≥n se conoce con **JavaScrip Object Notation (JSON)** y ha dado lugar a un formato de **ficheros, json**, convertido pr√°cticamente en el est√°ndar de intercambio de datos entre distintas capas de software (servidores, clientes...)

- se utilizan siempre dobles comillas (")
- las claves o propiedades siempre van entre comillas, al igual que los valores de tipo string

El formato literal es solo una notaci√≥n.
Los objetos obtenidos son exactamente los mismos que los que resultar√≠an del patron constructor: instancias de la misma funci√≥n constructora y con el mismo prototipo, del que pueden tomar las propiedades comunes a todas las instancias de dicha funci√≥n constructora (clase)

```js
const user = {
  name: 'Pepe',
  age: 22,
};

// Array
const numbers = [1, 2, 3, 4];

// Regular Expression (RegExp)
const regExp = /a/i;

console.log(user);
console.log(user.constructor); // [Function: Object]
console.log(Object.getPrototypeOf(user)); // [Object: null prototype] {}
console.log(user instanceof Object); // true

console.log(numbers);
console.log(numbers.constructor); // [Function: Array]
console.log(Object.getPrototypeOf(numbers)); // Object(0) []
console.log(numbers instanceof Object); // true
console.log(numbers instanceof Array); // true

console.log(regExp);
console.log(regExp.constructor); // [Function: RegExp]
console.log(Object.getPrototypeOf(regExp)); // {}
console.log(regExp instanceof Object); // true
console.log(regExp instanceof RegExp); // true
```

#### Objetos construidos

Desde la aparici√≥n de JS, Los objetos pueden crearse como nuevas **instancias** resultantes de emplear el patron constructor (new) con una **funci√≥n constructora**, de forma similar a como otros lenguajes utilizan las clases.

A partir de ES6, comienza a usarse la palabra reservada **class** y se habla de **clases** para referirse al proceso antes mencionado, de creaci√≥n de instancias a partir de funciones constructoras (ahora con apariencia de clases)

```js
const user = new Object({
  name: 'Pepe',
  age: 22,
});

console.log(user); // { name: 'Pepe', age: 22 }

// Array
const numbers = new Array(1, 2, 3, 4);
console.log(numbers); // [ 1, 2, 3, 4 ]

// Regular Expression (RegExp)
const regExp = new RegExp(/a/i);
console.log('RegExp new', regExp); // /a/i

// Date
const date = new Date();
console.log(date); // 2023-08-19T11:56:56.079Z

// Error
const error = new Error('Some error');
console.log(error); // Error: Some error
```

### Propiedades de los objetos

Cualquiera que sea la forma en que se han creado, los objetos tienen propiedades a las que se puede acceder mediante dos formas de notaci√≥n

- puntos (dot notation)
- corchetes (bracket notation)

```js
{
  const user = {
    name: 'Pepe',
  };
  console.log(user['name']); // Pepe

  const property = 'name';
  console.log(user[property]); // Pepe
}
```

La notaci√≥n de corchetes solo se utiliza si el **nombre de la propiedad** es una **variable**, que debe ser evaluada para luego acceder a la propiedad correspondiente al valor de la variable

Con ambas notaciones es posible leer, modificar crear y eliminar propiedades.

```js
const obj = {
  name: 'Pepe',
  age: 22,
};
// A√±adimos propiedades
obj.lastName = 'Perez';
// Modificamos propiedades
obj.name = 'Jose';
// Eliminamos propiedades
delete obj.age;
console.log(obj);
```

Todos estos cambios se enmarcan en el concepto de **mutabilidad** de los objetos

#### Niveles

Las propiedades de los objetos pueden ser otros objetos, dando lugar a tantos niveles de anidamiento o profundidad como sea necesario.

As√≠ se refleja tanto en su creaci√≥n como en el acceso a las propiedades en cualquiera de las notaciones.

```js
const user = {
  name: {
    firstName: 'Pepe',
    surname: 'Perez',
  },
};
user.address = {};
user.address.street = 'c/ del Pez';
user['address'].number = '22 3¬™ C';
user['address']['city'] = 'Teruel';

console.log(user);
// { name: { firstName: 'Pepe', surname: 'Perez' },
// address: { street: 'c/ del Pez', number: '22 3¬™ C', city: 'Teruel' } }
```

##### Anidamiento y propiedades undefined

Si se accede a cualquier propiedad de un objeto que no existe, el valor devuelto es undefined

Sin embargo si se intenta acceder a una propiedad de una propiedad que no existe, de desencadena un TypeError.

Para evitarlo puede usarse el operador **optional chaining** (?.), que no continua a un siguiente nivel de anidamiento cuando obtiene un undefined o null en el anterior, devolviendo en ese caso un undefined

```js
const obj = {
  name: 'Pepe',
  age: 22,
};
console.log(obj.address); // undefined
try {
  console.log(obj.address.city);
} catch (error) {
  console.log(error.name); // TypeError
  console.log(error.message); // Cannot read properties of undefined (reading 'city')
}
console.log(obj.address?.city); // undefined
```

##### Anidamiento y clonaci√≥n

Este posible anidamiento debe tenerse en cuenta al plantear el proceso de clonaci√≥n o deep copy de un objeto, consistente en crear una instancia nueva.

Algunas de las formas de obtener este resultado no lo hacen en profundidad, y solo crean una shallow copy de las estructuras anidadas:

- Object.assign()
- {...Object}

Existen otras alternativas que si crean una deep copy a todos los niveles:

- JSON.parse(JSON.stringify(object))
- structuredClone()

#### Iteraciones

Los objetos no son iterables, como arrays y strings, por lo que no pueden recorrerse en base a un √≠ndice num√©rico, como hacen for y for-of.

Las iteraciones en los objetos de JS pueden realizarse con la estructura **for-in**, que ya conocemos.

### Objetos y prototipos

Todos los objetos tiene una propiedad especial llamada `__proto__`" que apunta a otro objeto, conocido como su **prototipo**.
Los objetos acceden de forma transparente al objeto al que apunta la propiedad `__proto__`.

El prototipo de un objeto suele ser el **prototype** de la funci√≥n constructora del objeto. De esta forma se aplica el **patr√≥n prototype** para conseguir una relaci√≥n entre objetos asimilable a las **clases** de otros lenguajes de programaci√≥n

#### Propiedades del prototipo original

El prototipo por defecto de los objetos incluye una serie de propiedades y m√©todos accesibles de forma transparente por todos los objetos, que en general no se utilizan demasiado

```js
const obj = new Object({
  name: 'Pepe',
  age: 22,
});

console.log(obj.constructor);
console.log(obj.hasOwnProperty('name')); // true
console.log(obj.isPrototypeOf({})); // false
console.log(obj.propertyIsEnumerable('name')); // true
console.log(obj.toString()); // [object Object]
console.log(obj.toLocaleString()); // [object Object]
console.log(obj.valueOf()); // { name: 'Pepe', age: 22 }
```

![Objeto y su prototipo por defecto](assets/object.proto.svg)

#### Prototipos y funciones

En t√©rminos protot√≠picos, las funciones son objetos un poco especiales, que tienen una propiedad especial llamada `prototype` que apunta a otro objeto, conocido como su **prototipo**.

Este objeto, como cualquier otro, tiene una propiedad `__proto__` que por defecto apunta al prototipo de todos los objetos.

![Prototipo de una funci√≥n](assets/object.function.proto.svg)

Por su parte, el objeto prototipo por defecto de todos los dem√°s es el prototipo de la funci√≥n constructora Object.

Este objeto, como cualquier otro, tiene una propiedad `__proto__` que por defecto apunta a null.

![Prototipo de una funci√≥n](assets/final.proto.svg)

#### Cambiando el prototipos

Se puede crear un objeto literal que tenga como prototipo (`__proto__`) cualquier otro objeto

La forma "incorrecta" de hacerlo es mediante la asignaci√≥n directa de la propiedad `__proto__` al objeto literal

```js
const person = {
  teeth: 32,
  renderTeeth() {
    console.log('Tengo', this.teeth, 'dientes');
  },
};

const user = {
  name: 'Pepe',
  age: 22,
  __proto__:
}
user.__proto__= person;
```

La forma correcta de hacerlo es mediante la funci√≥n `Object.create()`, que recibe como argumento el objeto que se desea que sea el prototipo del nuevo objeto

```js
const person = {
  teeth: 32,
};

const user = Object.create(person);

user.name = 'Pepe';
user.age = 22;

console.log(user);
user.renderTeeth(); // Tengo 32 dientes
```

Otra forma tambi√©n v√°lida es usando Object.setPrototypeOf(), que recibe como primer argumentos el objeto al que se le va a cambiar el prototipo y como segundo el objeto que va a ser el nuevo prototipo

```js
const person = {
  teeth: 32,
};

const user = {
  name: 'Pepe',
  age: 22,
};

Object.setPrototypeOf(user, person);

console.log(user);
user.renderTeeth(); // Tengo 32 dientes
```

En cualquiera de los casos, el nuevo objeto podr√° acceder de forma transparenta a las propiedades de su prototipo, siempre que no existan en el mismo objeto

![Objetos como proto de otro objeto](assets/change.proto.svg)

#### Cadena de prototipos

La relaci√≥n entre objetos y prototipos puede ser en cadena, de forma que un objeto puede ser el prototipo de otro objeto que a su vez es el prototipo de otro objeto. Este patr√≥n se conoce como **cadena de prototipos** (**prototype chain**) y de lugar a la **herencia protot√≠pica**

Si una propiedad no se encuentra en el objeto, se busca en su prototipo, y as√≠ sucesivamente hasta llegar al prototipo de todos los objetos, Object.

```js
const alumno = {
  course: 'JavaScript',
  __proto__: person,
};

console.log(alumno);
console.log(alumno.name); // Pepe
alumno.renderTeeth(); // Tengo 32 dientes
```

![Cadena de prototipos (prototype chain)](assets/prototipe.chain.svg)

En cualquier punto de la cadena de prototipos puede darse es **ocultamiento** (**shadowing**) de propiedades disponibles en niveles superiores.
Si una propiedad se encuentra en el objeto, no se busca en su prototipo, ni en los sucesivos prototipos de la cadena.

## Paradigma funcional: funciones como objetos

Ya sabemos que en JS las funciones son tambi√©n valores y su tipo es el de **objetos 'de pleno derecho**.

Entre otras cosas

- pueden tener propiedades
- pueden ser asignadas a una variable
- pueden ser incluidas (anidadas) en otra funci√≥n
- pueden ser recibidas como par√°metros
- pueden ser devueltas por otra funci√≥n

### Funciones con propiedades 'extra'

Aunque no suele hacerse, una funci√≥n puede tener propiedades como cualquier otro objeto

```js
const foo = () => {
  console.log('Soy foo');
};

foo.date = new Date();

console.log(foo);
// [Function: foo] { date: 2023-08-16T11:23:04.205Z }
```

### Funciones anidadas

```js
function addSquares(a, b) {
  function square(x) {
    return x * x;
  }

  return square(a) + square(b);
}

console.log(addSquares(4, 5)); // 41
```

La funci√≥n 'interna' square solo existe en el scope de la otra y solo puede ser utilizada dentro de ella

### Funciones de orden superior y callbacks

Una funci√≥n de orden superior (**hight order function**) es la que

- recibe una funci√≥n como par√°metro
- devuelve una funci√≥n

La funci√≥n recibida como par√°metro se denomina **callback**

```js
const hof = (callback) => {
  console.log(callback());
};

hof(() => 'Soy un callback');
```

Los callback pueden ser indistintamente funciones con nombre o an√≥nimas, aunque esta segunda opci√≥n es muy habitual, como lo es en ese caso el uso de las arrow functions

Entre los usos m√°s habituales de los callbacks:

- permitir asignar funciones como manejadores de eventos as√≠ncronos
- asignar funciones a timeouts, como otra forma de asincron√≠a

### Funciones auto-invocadas

Despu√©s de la declaraci√≥n de una funci√≥n an√≥nima (expresi√≥n funcional), es posible que √©sta se invoque a si misma para ser ejecutada inmediatamente

El patr√≥n de esta pr√°ctica se denomina IIFE (**Immediately Invoked Function Expression**)

```js
(() => {
  console.log('Ejemplo de una IIFE');
})();
```

La creaci√≥n de su propio espacio de memoria en las funciones hace que se puedan utilizar para aislar un c√≥digo fuente y evitar colisiones de variables o espacios de nombres en general: El c√≥digo se ejecuta directamente, como si no hubiera funci√≥n, pero en su propio espacio de memoria

### Closures

Una funci√≥n que encapsula un conjunto de definiciones locales :

- variables,
- otras funciones (por extensi√≥n objetos).

Se basa por tanto en el anidamiento de funciones.

- permite que la funci√≥n interna "escape" de la funci√≥n padre: se hace accesible desde fuera
- la funci√≥n interna sigue teniendo acceso al √°mbito (scope) de la funci√≥n padre despu√©s de que √©sta haya retornado

El √°mbito de visibilidad de la funci√≥n externa se utiliza para crear el equivalente a un m√≥dulo

Las funciones internas pueden ser setters y getters de variables locales, no accesibles directamente desde fuera

Se pueden utilizar varios patrones para conseguir un closure:

- una funci√≥n incluye una funci√≥n interna y la devuelve
- una funci√≥n incluye una funci√≥n interna y se la asigna a una variable del nivel superior

```js
const closureCount = () => {
  let counter = 0;
  return () => counter++;
};

const extCounter = closureCount();

console.log(extCounter()); // 0
console.log(extCounter()); // 1
console.log(extCounter()); // 2
```

En el primero de los patrones puede a√±adirse una IIFE

```js
const closureCount = (() => {
  let counter = 0;
  return () => counter++;
})();

console.log(closureCount()); // 0
console.log(closureCount()); // 1
console.log(closureCount()); // 2
```

## Paradigma de orientaci√≥n a objetos: clases

Como hemos visto, en JS Los objetos pueden declararse:

- literalmente
- con el patron constructor

Los objetos literales tienen como caracter√≠stica que en principio creamos cada uno de forma independiente, lo que en muchos contextos no es lo m√°s adecuado.

```js
const user1 = {
  name: 'Pepe',
  age: 22,
  greeting() {
    console.log(`Hola, soy ${this.name}`);
  },
};

const user2 = {
  name: 'Ernestina',
  age: 23,
  greeting() {
    console.log(`Hola, soy ${this.name}`);
  },
};

user1.greeting();
user2.greeting();

console.log(user1);
console.log(user2);
```

La alternativa es el patr√≥n constructor, y para entenderlo es necesario conocer los distintos patrones de ejecuci√≥n de las funciones en JS.

### Patrones de ejecuci√≥n de las funciones

Una funci√≥n puede ser ejecutada de 4 formas diferentes, y en cada una de ellas el valor de `this` es diferente

Tomamos como ejemplo una funci√≥n que simplemente imprime el valor de `this`

```js
function foo() {
  console.log('Este es el valor de this:', this);
}
```

Podemos ejecutarla siguiendo 4 patrones diferentes

- como una funci√≥n (**function pattern**)

El valor de this depende de si esta activado o no el modo estricto

- si no lo est√°, this es el objeto global
- si lo est√°, this es undefined

```js
foo(); // Este es el valor de this: <ref *1> Object [global] { ... }

('use strict');
foo(); // Este es el valor de this: undefined
```

- como un m√©todo (**method pattern**)

El valor de this es el objeto al que pertenece la funci√≥n
Para probarlo asignamos la funci√≥n a una propiedad de un objeto y la invocamos

```js
const obj = {
  foo, // Eq. foo: foo
};

obj.foo(); // Este es el valor de this: { foo: [Function: foo] }
```

- como un constructor (**constructor pattern**)

La funci√≥n se invoca con el operador new, y el valor de this es un objeto vac√≠o que se crea autom√°ticamente y se asigna a la variable this

```js
new foo(); // Este es el valor de this: foo {}
```

- de forma indirecta (**apply/call pattern**)

La funci√≥n puede ser invocada desde el contexto de otro objeto, mediante los m√©todos apply o call de la propia funci√≥n, que permiten asignar un valor a this pasado como argumento.

```js
const obj2 = {
  name: 'Object 2',
};

foo.apply(obj2); // Este es el valor de this: { name: 'Object 2' }
```

En definitiva vemos que cualquier funci√≥n puede ser un constructor, cuando se una el operador new. En ese caso

1 - Se crea un objeto nuevo
2 - Este es asignado a la propiedad this de la funci√≥n
3 - El c√≥digo de la funci√≥n puede modificar el objeto reci√©n creado
3 - La funci√≥n devuelve el objeto

### Funciones constructoras

Lo interesante es implementar funciones pensadas para ser usadas como constructores, y que devuelvan un objeto con propiedades y m√©todos. Estas funciones se denominan **funciones constructoras** y pos convenio se escriben con la primera letra en may√∫sculas

```js
function User(name, age) {
  this.name = name;
  this.age = age;
  this.greeting = function () {
    console.log(`Hola, soy ${this.name}`);
  };
}

const user1 = new User('Pepe', 33);
const user2 = new User('Ernestina', 22);
const user3 = new User('Ramon', 45);

console.log(user1);
console.log(user2);
console.log(user3);
```

El patr√≥n constructor es el m√°s habitual en la **programaci√≥n orientada a objetos** en JS, y se utiliza para crear instancias de objetos que comparten propiedades y m√©todos.

De forma similar a como hacen las clases en otros lenguajes, las funciones constructoras permiten crear instancias de objetos con propiedades y m√©todos comunes.
Hay sin embargo una importante diferencia entre ambos conceptos:

- Los objetos basados en clases de otros lenguajes se ajusta r√≠gidamente a las definiciones de la clase, que pueden entenderse como **plantillas** con las que se crean objetos
- Los objetos basados en funciones constructoras de JS son tan flexibles como los objetos literales, y permiten la creaci√≥n de objetos con propiedades y m√©todos comunes, pero tambi√©n la modificaci√≥n de esas propiedades y m√©todos en cada instancia

```js
const user4 = new User('Pepe', 33);
user4.surname = 'Perez';
delete user4.age;

console.log(user4); // { name: 'Pepe', greeting: [Function], surname: 'Perez' }
```

#### Funciones constructoras y prototipos

Cuando una funci√≥n utiliza el patr√≥n constructor, se crea un objeto que tiene como prototipo el prototipo de la funci√≥n constructora.

```js
const User = function (name, age) {
  this.name = name;
  this.age = age;
};

Person.prototype.teeth = 32;

const pepe = new Person('Pepe', 22);
console.log(pepe);
console.log(pepe.teeth); // 32
```

El objeto creado con el operador new tiene adem√°s una propiedad especial `constructor` que apunta a la funci√≥n constructora.

```js
pepe.__proto__ === Person.prototype; // true
pepe.constructor === Person; // true
```

![Prototipos y funciones constructoras](assets/constructor.prototype.svg)

#### M√©todos de instancia y m√©todos de prototipo

En el ejemplo anterior, el m√©todo `greeting` es un m√©todo de instancia, ya que se crea en cada objeto creado con la funci√≥n constructora. Esto puede ser un problema si se crean muchos objetos, ya que se duplica el c√≥digo de la funci√≥n en cada uno de ellos.

En JS lo habitual es almacenar los m√©todos en el prototipo de la funci√≥n constructora, de forma que se comparten entre todas las instancias de la funci√≥n constructora, siendo accesibles de forma transparente, como ya sabemos que sucede con todas las propiedades del prototipo. As√≠ se muestra en la imagen anterior

```js
const User = function (name, age) {
  this.name = name;
  this.age = age;
};

User.prototype.greeting = function () {
  console.log(`Hola, soy ${this.name}`);
};

const pepe = new User('Pepe', 22);
const ernestina = new User('Ernestina', 23);

pepe.greeting();
ernestina.greeting();

console.log(pepe);
console.log(ernestina);
```

#### Propiedades y M√©todos est√°ticos (de "clase")

La propia funci√≥n constructora puede tener propiedades y m√©todos que no se comparten con las instancias de la funci√≥n constructora, sino que son propias de la funci√≥n constructora.

Estas propiedades y m√©todos se denominan **est√°ticos** y se definen directamente en la funci√≥n constructora

```js
const User = function (name, age) {
  this.name = name;
  this.age = age;
  User.count++;
};

User.prototype.greeting = function () {
  console.log(`Hola, soy ${this.name}`);
};

User.count = 0;
User.getCount = function () {
  return User.count;
};

const pepe = new User('Pepe', 22);
const ernestina = new User('Ernestina', 23);

console.log(User.getCount()); // 2
```

#### Herencia

En JS la herencia se basa en la cadena de prototipos, y se consigue mediante la asignaci√≥n de un objeto a la propiedad `prototype` de la funci√≥n constructora

```js
const Person = function (name, age) {
  this.name = name;
  this.age = age;
};

Person.prototype.greeting = function () {
  console.log(`Hola, soy ${this.name}`);
};

const Student = function (name, age, course) {
  Person.call(this, name, age);
  this.course = course;
};

Student.prototype = Object.create(Person.prototype);
// Student.prototype.__proto__ = Person.prototype;
Student.prototype.constructor = Student;

Student.prototype.greeting = function () {
  Person.prototype.greeting.call(this);
  console.log(`Estudio ${this.course}`);
};

const pepe = new Student('Pepe', 22, 'JavaScript');
pepe.greeting();
```

En este caso, la funci√≥n constructora Student hereda de la funci√≥n constructora Person, y se crea una nueva cadena de prototipos, en la que el prototipo de Student es el prototipo de Person.

![Herencia en JS](assets/proto.inheritance.svg)

#### Funciones constructoras nativas de JS

JS incluye funciones constructoras nativas que permiten crear objetos de tipos primitivos y objetos

- String
- Number
- Boolean
- Array
- Object
- Function
- ...

En los prototipos de estas funciones constructoras se encuentran los m√©todos y propiedades que permiten trabajar con estos tipos de datos, al ser accedidas de forma transparente por todos los objetos creados con estas funciones constructoras.

```js
const str = 'Hola';
console.log(str.length); // 4
console.log(str.toUpperCase()); // HOLA
const arr = [1, 2, 3];
console.log(arr.length); // 3
console.log(arr.push(4)); // 4
console.log(Array.isArray(arr)); // true
```

En muchos casos, estas funciones constructoras se utilizan tanbien como funciones de conversi√≥n de tipos, para convertir valores de un tipo a otro, cuando de invocan con el patr√≥n function, es decir sin el operador new

```js
const num = Number('22');
console.log(typeof num); // number
```

Todas ellas heredan de la funci√≥n constructora Object, y por tanto tienen acceso a las propiedades y m√©todos de Object, que por su parte tiene como prototipo el valor null, que de esa forma pone fin a la cadena de prototipos.

```js
const data = [1, 2, 3];
console.log(data.constructor); // [Function: Array]
console.log(data instanceof Array); // true
console.log(data instanceof Object); // true

const foo = () => {};
console.log(foo.constructor); // [Function: Function]
console.log(foo instanceof Function); // true
console.log(foo instanceof Object); // true

const obj = {};
console.log(obj.constructor); // [Function: Function]
console.log(obj instanceof Object); // true
```

![Funciones constructoras nativas y creadas por el usuario](assets/native.constructors.svg)

### Clases en ES6

A partir de ES6, JS incluye la palabra reservada **class** que permite definir una funci√≥n constructora de forma m√°s clara y sencilla, y que se asemeja a la sintaxis de las clases de otros lenguajes de programaci√≥n.

Internamente no cambia nada respecto a lo que hemos visto hasta ahora, y sigue siendo una funci√≥n constructora que crea objetos con propiedades y m√©todos. Por eso se dice que las clases en JS son **az√∫car sint√°ctica**. Prueba de ello es que los objetos siguen siendo igual de flexibles que antes

```js
export class User {
  constructor(name, age) {
    this.name = name;
    this.#age = age;
  }

  greeting() {
    console.log(`Hola, soy ${this.name} y tengo ${this.#age} a√±os`);
  }
}

const user1 = new User('Pepe', 33);
const user2 = new User('Ernestina', 22);
const user3 = new User('Ramon');

user1.greeting();
user2.greeting();

// Los objetos siguen siendo igual de flexibles que antes
user1.surname = 'Perez';
delete user1.age;

console.log(user1);
console.log(user2);
console.log(user3);
```

Su uso hoy en d√≠a esta muy extendido y es el m√°s habitual en la programaci√≥n orientada a objetos en JS. Algunas novedades posteriores a ES6 han mejorado su funcionalidad, como la posibilidad de declarar propiedades est√°ticas y m√©todos est√°ticos, y la posibilidad de declarar propiedades privadas. Con ello la OOP en JS al menos en t√©rminos formales, se ha acercado m√°s a la de otros lenguajes de programaci√≥n.

```js
export class User {
  static brand = 'CAS';

  static foo = function () {
    console.log('M√©todo est√°tico');
  };

  name;
  #age;

  constructor(name, age) {
    this.name = name;
    this.#age = age;
  }

  greeting() {
    console.log(`Hola, soy ${this.name} y tengo ${this.#age} a√±os`);
  }
}

const user1 = new User('Pepe', 33);

user1.greeting();

console.log(User.brand);
User.foo();

console.log(user1);
```

En el caso de la herencia, las ventajas del nuevo formato son aun m√°s evidentes, ya que la sintaxis es mucho m√°s clara y sencilla

```js
export class Student extends User {
  constructor(name, age, course = 'Angular') {
    super(name, age);
    this.course = course;
  }

  greeting() {
    super.greeting();
    console.log(`Estudio ${this.course}`);
  }
}

const s1 = new Student('Elena', 34, 'Node');
s1.greeting();
console.log(s1);
```

### Accessors: getters y setters

A partir de ES5, JS incluye la posibilidad de declarar propiedades de un objeto como getters y setters, que permiten controlar la lectura y escritura de las propiedades de un objeto.

Estos m√©todos han cobrado mayor sentido al aparecer la posibilidad de declarar propiedades privadas en las clases de ES6.

Sin embargo, el uso de getters y setters aparece como una mala practica en la mayor√≠a de las referencias a la OOP como paradigma de programaci√≥n.

```js
export class User {
  #name;
  #age;

  constructor(name, age) {
    this.#name = name;
    this.#age = age;
  }

  get name() {
    return this.#name;
  }

  set name(value) {
    this.#name = value;
  }

  get age() {
    return this.#age;
  }

  set age(value) {
    this.#age = value;
  }

  greeting() {
    console.log(`Hola, soy ${this.#name} y tengo ${this.#age} a√±os`);
  }
}

const user1 = new User('Pepe', 33);
user1.greeting();

console.log(user1.name);
user1.name = 'Ernestina';
console.log(user1.name);
```

### JS y la programaci√≥n orientada a objetos

Como acabamos de ver las novedades de ES6 y versiones posteriores han acercado la programaci√≥n orientada a objetos en JS a la de otros lenguajes de programaci√≥n, pero no han cambiado la naturaleza de JS como lenguaje de programaci√≥n.

JS sigue siendo un lenguaje de programaci√≥n orientado a objetos, pero no basado en clases, sino en prototipos, y con una sintaxis que permite la creaci√≥n de objetos de forma literal, con funciones constructoras, o aparentemente con clases.

Los objetos en JS son tan flexibles como los objetos literales, y permiten la creaci√≥n de objetos con propiedades y m√©todos comunes, pero tambi√©n la modificaci√≥n de esas propiedades y m√©todos en cada instancia. Todo ello no es muy coherente con el concepto de **encapsulaci√≥n**

Adem√°s una diferencia de JS respecto a otros lenguajes de programaci√≥n es la falta de **clases abstractas** e **interfaces**. Ello dificulta la abstracci√≥n y el polimorfismo basado en interfaces, la creaci√≥n de jerarqu√≠as de clases y la aplicaci√≥n de determinados patrones habituales en OOP.

Una de las formas de abordar estas limitaciones es el uso de **TypeScript**, un **super-conjunto de JS** que a√±ade tipado est√°tico y caracter√≠sticas de OOP como objetos mucho menos manipulables, clases abstractas e interfaces, y que se compila a JS.

#### Relaciones entre clases

- Asociaci√≥n (‚Äî‚Äî): la relaci√≥n entre dos unidades separadas. Se busca el punto en com√∫n entre las entidades y se establecen v√≠nculos entre ellas. La asociaci√≥n permite realizar conexiones l√≥gicas a trav√©s de una referencia continua.

- Composici√≥n / Agregaci√≥n (composici√≥n): las clases perteneces a otra, la construyen. son dos subconjuntos de la asociaci√≥n;

  - Agregaci√≥n (‚Äî‚óÅ‚ñ∑): una clase es parte de otra clase (composici√≥n **d√©bil**). Los componentes pueden ser compartidos por varios compuestos (de la misma asociaci√≥n de agregaci√≥n o de varias asociaciones de agregaci√≥n distintas). La destrucci√≥n del compuesto no conlleva la destrucci√≥n de los componentes. Habitualmente se da con mayor frecuencia que la composici√≥n.
  - Composici√≥n (‚Äî‚óÄ‚ñ∂): supone que la vida de la clase contenida debe coincidir con la vida de la clase contenedor. Los componentes constituyen una parte del objeto compuesto. De esta forma, los componentes no pueden ser compartidos por varios objetos compuestos. La supresi√≥n del objeto compuesto conlleva la supresi√≥n de los componentes.

<https://www.seas.es/blog/informatica/agregacion-vs-composicion-en-diagramas-de-clases-uml/>
